clear;
clc;
%Number of elements in transformation monoid
elements = 4;
%Actual table of all mappings
combos = allValidCombos(elements);
%All compositions of mappings
compTable = compositionTable(combos);
%Largest transformation monoid size wanted
maxSize = elements^elements;
%maxSize = 5;

%All families generated by singular elements (and identity)
fams = cell(1,size(combos,1));
%Produce default array whose rows are all identity)
onesCol = ones(landau(elements),1);
idRow = combos(identity(elements),1:end);
defArray = onesCol * idRow;
id = identity(elements);
%Generate family from each mapping
for i = 1:1:size(combos,1)
    index = i;
    while(ismember(index,fams{i}) == 0)
        %Populate family with power
        fams{i} = [fams{i}, index];
        %Obtain power through composition
        index = compTable(index,i);
    end
    %Remove redundant indices and sort
    fams(i) = {sort([setdiff(fams{i},id),id])};
end
%Remove all redundant families
fams = redundantCell(fams);
clearvars onesCol idRow defArray index

%HARDCODED FOR NOW
maxHash = 513;

%Create monoid table
monTable = cell(maxSize,1);
%Populate table with empty cell column
for i = 1:1:maxSize
    monTable{i,1} = cell(1,maxHash);
end
%Populate each empty cell with family of apt size
for i = 1:1:size(fams,2)
    monTable{size(fams{i},2),1}{hashFun(fams{i})}{end+1} = fams{i};
end
clearvars fams

dcLoop = 0;
while(~dcLoop)
    dcLoop = 1;
    %Make new column
    monTable(1:end,end+1) = cell(maxSize,1);
    for i = 1:1:maxSize
        monTable{i,end} = cell(1,maxHash);
        for j = 1:1:maxHash
            monTable{i,end}{j} = cell(1,0);
        end
    end
    
    for c1ind = 2:1:maxSize-1
        for c1rhash = 1:1:size(monTable{c1ind,1},2)
           for c1rhashind = 1:1:size(monTable{c1ind,1}{c1rhash},2)
               for cendind = 2:1:maxSize-1
                    for cendrhash = 1:1:maxHash
                        for cendrhashind = 1:1:size(monTable{cendind,end-1}{cendrhash},2)
                            product = closure(monTable{c1ind,1}{c1rhash}{c1rhashind},monTable{cendind,end-1}{cendrhash}{cendrhashind},compTable,maxSize,id);
                            prodsize = size(product,2);
                            if(prodsize <= maxSize)
                                hash = hashFun(product);
                                [logic,monTable{prodsize,end}{hash}] = inclusionDiff(monTable{prodsize,end}{hash}, product);
                                if logic == 1
                                    dcLoop = 0;
                                end
                            end
                        end
                    end
               end
            end
        end
    end
    
    for i = 1:1:maxSize
        for j = 1:1:size(monTable,2)-1
            for k = 1:1:size(monTable{i,j},2)
                monTable{i,end}{k} = pruneCell(monTable{i,j}{k},monTable{i,end}{k});
            end
        end
    end
end
clearvars dcLoop logic product prodsize compTable combos i j k m id

%Print out all found monoids
for i = 1:1:maxSize
    sizeI = 0;
    for j = 1:1:size(monTable,2)
        for k = 1:1:maxHash
            sizeI = sizeI + size(monTable{i,j}{k},2);
        end
    end
    disp([num2str(i),': ',num2str(sizeI)]);
end
clearvars i j maxHash sizeI sizeCell