clear;
clc;
%Number of elements in transformation monoid
elements = 4;
%Actual table of all mappings
combos = allValidCombos(elements);
%All compositions of mappings
compTable = compositionTable(combos);
%Largest transformation monoid size wanted
maxSize = elements^elements;
%maxSize = 5;

%All families generated by singular elements (and identity)
fams = cell(1,size(combos,1));
%Produce default array whose rows are all identity)
onesCol = ones(landau(elements),1);
idRow = combos(identity(elements),1:end);
defArray = onesCol * idRow;
id = identity(elements);
%Generate family from each mapping
for i = 1:1:size(combos,1)
    index = i;
    while(ismember(index,fams{i}) == 0)
        %Populate family with power
        fams{i} = [fams{i}, index];
        %Obtain power through composition
        index = compTable(index,i);
    end
    %Remove redundant indices and sort
    fams(i) = {sort([setdiff(fams{i},id),id])};
end
%Remove all redundant families
fams = redundantCell(fams);
clearvars onesCol idRow defArray index

%Create monoid table
monTable = cell(0,0);
%Populate table with empty cell column
for i = 1:1:maxSize
    monTable{i,1} = cell(0,0);
end
%Populate each empty cell with family of apt size
for i = 1:1:size(fams,2)
    monTable{size(fams{i},2),1}{end+1} = fams{i};
end
clearvars fams

dcLoop = 0;
while(~dcLoop)
    dcLoop = 1;
    %Make new column
    monTable(1:end,end+1) = cell(maxSize,1);
    for i = 2:1:maxSize-1
        for j = 1:1:size(monTable{i,1},2)
           for k = 2:1:maxSize-1
               for m = 1:1:size(monTable{k,end-1},2)
                    product = closure(monTable{i,1}{j},monTable{k,end-1}{m},compTable,maxSize,id);
                    prodsize = size(product,2);
                    if(prodsize <= maxSize)
                        [logic,monTable{prodsize,end}] = inclusionDiff(monTable{kprodsize,end}, product);
                        if logic == 1
                            dcLoop = 0;
                        end
                    end
                end
            end
        end
    end
    
    for i = 1:1:maxSize
        for j = 1:1:size(monTable,2)-1
            monTable{i,end} = pruneCell(monTable{i,j},monTable{i,end});
        end
    end
end
clearvars dcLoop logic product prodsize compTable combos i j k m id

%Print out all found monoids
for i = 1:1:maxSize
    sizeI = 0;
    for j = 1:1:size(monTable,2)
        if(isempty(monTable(i,j)))
            sizeCell = 0;
        else
            sizeCell = size(monTable{i,j},2);
        end
        sizeI = sizeI + sizeCell;
    end
    disp([num2str(i),': ',num2str(sizeI)]);
end
clearvars i j sizeI sizeCell