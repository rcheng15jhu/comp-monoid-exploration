clear;
clc;
%Number of elements in transformation monoid
elements = 4;
%Actual table of all mappings
combos = allValidCombos(elements);
%All compositions of mappings
compTable = compositionTable(combos);
%Largest transformation monoid size wanted
%maxSize = elements^elements;
maxSize = 7;

%All families generated by singular elements (and identity)
fams = cell(1,size(combos,1));
%Produce default array whose rows are all identity)
id = identity(elements);
%Generate family from each mapping
for i = 1:1:size(combos,1)
    index = i;
    while(ismember(index,fams{i}) == 0)
        %Populate family with power
        fams{i} = [fams{i}, index];
        %Obtain power through composition
        index = compTable(index,i);
    end
    %Remove redundant indices and sort
    fams{i} = sort([setdiff(fams{i},id),id]);
end
%Remove all redundant families
fams = redundantCell(fams);
clearvars index

%HARDCODED FOR NOW
maxHash = 383;

%Create monoid table
monTable = cell(maxSize,1);
%Populate table with empty cell column
for i = 1:1:maxSize
    monTable{i,1} = cell(1,maxHash);
end
%Populate each empty cell with family of apt size
for i = 1:1:size(fams,2)
    monTable{size(fams{i},2),1}{hashFun(fams{i})}{end+1} = fams{i};
end
clearvars fams

dcLoop = 0;
while(~dcLoop)
    dcLoop = 1;
    %Make new column
    monTable(1:end,end+1) = cell(maxSize,1);
    for i = 1:1:maxSize
        monTable{i,end} = cell(1,maxHash);
        for j = 1:1:maxHash
            monTable{i,end}{j} = cell(1,0);
        end
    end
    
    for c1i = 2:1:maxSize-1
        for c1rh = 1:1:size(monTable{c1i,1},2)
           for c1rhi = 1:1:size(monTable{c1i,1}{c1rh},2)
               for cei = 2:1:maxSize-1
                    for cerh = 1:1:maxHash
                        for cerhi = 1:1:size(monTable{cei,end-1}{cerh},2)
                            product = closure(monTable{c1i,1}{c1rh}{c1rhi},monTable{cei,end-1}{cerh}{cerhi},compTable,maxSize,id);
                            prodsize = size(product,2);
                            if(prodsize <= maxSize)
                                hash = hashFun(product);
                                [logic,monTable{prodsize,end}{hash}] = inclusionDiff(monTable{prodsize,end}{hash}, product);
                                if logic == 1
                                    dcLoop = 0;
                                end
                            end
                        end
                    end
               end
            end
        end
    end
    
    for i = 1:1:maxSize
        for j = 1:1:size(monTable,2)-1
            for k = 1:1:size(monTable{i,j},2)
                monTable{i,end}{k} = pruneCell(monTable{i,j}{k},monTable{i,end}{k});
            end
        end
    end
end
clearvars dcLoop logic product prodsize compTable combos c1i c1rh c1rhi cei cerh cerhi hash id

%Print out all found monoids
for i = 1:1:maxSize
    sizeI = 0;
    for j = 1:1:size(monTable,2)
        for k = 1:1:maxHash
            sizeI = sizeI + size(monTable{i,j}{k},2);
        end
    end
    disp([num2str(i),': ',num2str(sizeI)]);
end
clearvars i j k maxHash sizeI sizeCell